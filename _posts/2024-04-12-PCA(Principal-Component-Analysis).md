---
layout: single
title: PCA(Principal Component Analysis)
category: Mathmatics
tag: [Linear-Algibra, Machine-Learning]
toc: true
use_math: true 

---

# PCA

## PCA란 무엇인가?

---

PCA란 Principal Component Analysis의 약자로 한국어로 번역하면 주성분 분석이라는 뜻이며,

고 차원의 데이터가 주어졌을 때 저 차원의 데이터로 변환 시키기 위해 dimension reduction(차원 축소)를 수행하며, 기존 변수를 조합해 새로운 변수를 만들어 내는 변수 추출(feature extraction)기법이다.

그럼 주성분 즉 Principal Component란 무엇인가?

전체 데이터의 분산을 가장 잘 나타내는 성분을 주성분이라고 합니다.

## 그럼 도대체 PCA를 왜 사용하는거고 어떤 목적 때문에 쓰는거임?

---

1)차원 축소를 통하여 사람이 시각적으로 잘 인식 할 수 있는 2차원으로 데이터들을 보여줄 수 있기 때문이다.

만약 데이터가 예를 들어 1000차원이라면 우리는 그 데이터를 시각적으로 보았을 때 과연 이 데이터가 어떻게 분포가 되어 있으며 데이터의 분포도 혹은 데이터들의 관계가 어떤 관계인지 잘 알 수 있을까? 전혀 알 수 없다.

애초에 1000차원은 우리가 시각적으로 볼 수도 없으며 구현하기도 힘들다.

2)차원의 저주

차원의 저주는 데이터의 차원이 증가할 수록 데이터의 개수는 그대로 이지만 데이터 공간은 커지기 때문에 데이터의 밀도가 희소 해지는 현상이다.

???: 그럼 데이터의 밀도가 희소해지면 어떤 현상이 발생함?

만약 데이터의 차원이 커지고 데이터의 밀도가 희소하게 된다면 차원의 공간 별로 데이터의 특성 (feature)을 추출하기가 힘들 것이고 특성을 추출하기 위해서 더 많은 양의 데이터를 필요로 하게 된다 이는 연산량 증가를 일으키게 된다는 문제점이 발생하게 된다.

또한 데이터가 적어 공간 별 데이터 특성 추출이 제한된다면 데이터가 밀집된 특정 공간에서만 특성 추출이 됩니다. 그럼 소수의 데이터만 학습하게 되며 학습한 소수의 데이터에 관한 문제는 잘 맞추게 되지만 그 외에는 못 맞추게 되는 overfitting으로 이어지게 된다.

3)다중공선성(multicollinearity)

다중공선성은 독립 변수들 사이에 강한 상관 관계가 있을 때 발생하는 문제이다.

그럼 이 문제는 도대체 어떤 문제일까? 그리고 왜 이게 문제가 되는걸까?

먼저 회귀 분석의 4가지 가정에 대해 위반 되기 때문입니다.

1)선형성(Linearity)

2)잔차의 등분산(Equal Variance)

3)잔차의 정규성(Normality)

4)다중공선성에 만족되지 않는다(변수의 독립성)

회귀 분석은 각 변수들이 독립 변수이어야 하며 변수들 간의 독립성이 유지되어야 합니다.

왜냐하면 각 변수들 간의 독립성이 유지되지 않게 된다면 결과(target)를 판단하기 위해 필요한 변수가 중복되어 같은 요인을 중복되어 설명할 수 있다는 것을 의미하고 이는 계산량 증가와 예측력(설명력)을 떨어뜨릴 수 있기 때문입니다.

그럼 쉽게 예시를 들어보도록 하겠습니다.

만약 우리가 카페인 섭취에 따른 심장 박동수에 대해 회귀 분석을 한다고 해보도록하겠습니다.

x1: 하루에 마시는 커피 개수

x2:하루에 먹는 카페인의 양

y: 심장 박동 수

이렇게  변수를 지정한다고 하였을 때 x1과 x2는 독립변수 이지만 과연 종속성이 정말 없을까요?

오히려 종속성이 너무 크죠.

왜냐하면 하루에 마시는 커피 개수가 많을 수록 하루에 먹는 카페인의 양이 많기 때문입니다.

x1이 커지게 되면 x2도 커지게되고 결국에는 y값도 커지게 됩니다. 그 반대로 x1이 작게되면 x2도 커지게 되고 결국에는 y값도 작아지게 되죠.

그럼 이게 왜 문제가 되는걸까요?

결과적으론 카페인을 많이 섭취할 수록 심장 박동수가 올라가는 것도 맞고, 커피를 많이 마실 수록 심장 박동수가 올라가는거는 틀린게 아니지 않냐. 라고 생각하실 겁니다.

중요한 건 우리가 회귀 분석을 하는 이유는 각 독립 변수가 결과에 미치는 영향의 정도를 알기 위함인데. 이렇게 종속성이 너무 커져버리면 각 독립 변수가 결과에 미치는 영향을 정도를 알 수 없다는 겁니다.

또한 위 예제의 경우도 분명히 결과에 영향을 미치는 독립 변수는 2개인데 두 독립 변수의 종속성이 너무 강하기 때문에 결국에는 영향을 미치는 독립 변수는 1개와 똑같다는 거죠.

왜냐하면 하나의 독립 변수가 높아지면 다른 하나의 독립 변수도 높아지게 되고 이는 결국 독립 변수 한 개의 값에 따라 다른 독립 변수의 결과 값도 정해져 버리며 이는 결과(target)값이 정해지게 된다는 것 입니다.

예시에서는 독립 변수가 2개 였지만 만약 여러 개의 독립 변수 중에서 결과 값에 영향을 주는 feature만 select하게 되었을 때 서로 종속 되어 있는 독립 변수들을 뽑게 된다면 어떻게 될까요?

그 feature들로 target을 예측 하였을 때 그 target은 신뢰성과 예측력이 떨어지게 될 수 있습니다. 즉 잘못된 예측을 할 수 있다는거죠.

참고하기 위해 이 블로그를 참고하면 좋을것 같습니다

[링크: [https://seeyapangpang.tistory.com/17](https://seeyapangpang.tistory.com/17)]

## PCA의 원리

---

PCA는 고차원의 데이터를 저차원으로 데이터로 차원 축소를 하였을 때 전체 데이터의 특성을 잘 나타내는 주성분을 분석하는거라고 하였습니다.

그럼 고차원의 데이터를 저차원으로 줄이기 위해서 어떻게 해야할까요?

우리가 만약 2차원의 데이터를 1차원으로 줄인다고 가정해보도록 합시다.

![Untitled](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/27bb638c-a2b2-4717-adda-83aee93895fa)

만약 우리가 2차원의 데이터를 1차원으로 줄인다고 하면 기준이 되는 한 개의 선에 정사영을 하여 차원을 줄일겁니다.

그런데 중요한 건  어떤 선을 정사영을 하기 위한 축으로 사용할 건가 입니다.

![Untitled 1](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/82198089-b1e6-4c7d-836a-dddde89db63e)

만약 우리가 x1축 혹은 x2축을 기준으로 정사영을 하게 된다면 어떻게 될까요?

차원 축소를 통해 겹치는 데이터가 발생하며 이는 데이터 손실로 이어지게 됩니다.

그럼 데이터 손실이 일어나지 않기 위해서는 아래 그림과 같이 정사영을 했을 때 데이터 손실이 가장 덜 일어나는 축을 찾아야 합니다.

![Untitled 2](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/72f7c0a6-3105-4767-a304-4226cfc8d46f)

어떻게 하면 데이터 손실이 가장 덜 일어나는 축을 찾을 수 있을까요?

데이터 손실이 가장 덜 일어나는 축을 선정한다는 것은 데이터의 분포를 가장 잘 나타내는 선을 찾는다는 의미이고 데이터의 분포를 가장 잘 나타내는 선은 데이터의 평균 점으로부터 시작하는 벡터 입니다. 

그리고 이 벡터는 바로 많은 강의나 블로그에 나와 있듯이 데이터의 분산이 최대가 되는 벡터입니다.

그럼 여기서 의문이 들 수 있습니다.

도대체 왜? 데이터 손실이 가장 덜 일어나는 축을 찾기 위해서는 데이터의 분산이 최대가 되는 축을 찾아야 할까요?

그 이유를 한번 PCA의 진행 과정을 설명하면서 말씀드리도록 하겠습니다.

## PCA 진행 과정

---

1)각 축에 대한 평균 값을 구한 뒤 해당 점을 원점으로서 기준점으로 정한 뒤 데이터를 기준 점으로 shift한다.

![Untitled 3](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/3ed4a830-5d6b-4b4f-8c4a-107a6a6079b4)

먼저 데이터의 분포를 가장 잘 나타내는 선은 데이터의 평균 점으로부터 시작하는 벡터이기 때문에 

먼저 데이터의 평균을 나타내는 점을 구한 뒤 해당 점을 원점으로서 기준 점으로 정하고 데이터를 기준 점으로 옮겨 보도록 하겠습니다. 

 

2)원 점을 지나며 데이터의 분산을 가장 잘 나타내는 벡터를 찾는다.

![Untitled 4](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/562693ee-6088-4e2e-9dcc-185bdc1c2059)

???:원점을 지나는 직선이 몇 개인데 그걸 어캐 찾음?

다~ 방법이 있습니다. 

그것은 바로 모든 데이터를 우리가 찾은 직선에 정사영 하였을 때 원래 데이터와 정사영 된 데이터의 차이 값을 각 데이터 별로 구하여 평균을 구한 뒤 이 평균 값이 가장 작은 직선을 찾으면 되는 겁니다. 

이를 그럼 수식으로 풀어보겠습니다.

![Untitled 5](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/42cd2e9a-b608-4448-b1cc-3338eade8b2b)

위의 사진과 같이 X를 n x p크기의 데이터 행렬이라고 합시다.

여기서 n의 의미는 표본(sample)의 개수이고, p는 데이터의 특성(feature)이라고 합시다.

데이터 행렬 X의 (i,j)성분은 i번째 표본의 j번째 확률 변수 Xj에 대한 하나의 데이터를 의미한다.

![Untitled 6](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/4c74ff65-a3f7-4df4-9559-eb8114467a67)

위의 X bar는 X의 각 열의 평균을 구하는 값이라고 정의하겠습니다.

![Untitled 7](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/a42b9d42-cf14-4bfe-bc0f-dae9a933cbbb)

그리고 위 그림과 같이 각 열별로 각 데이터에서 (열의 평균)을 뺍니다.

그리고 이렇게 센터링 된 행렬을 구합니다.

여기서 센터링된 행렬의 각 열의 평균은 0이 됩니다. 그래서 이 센터링된 행렬을 mean-centered 행렬이라고 합니다.

그 다음 우리가 구해야할 것은 데이터의 분포를 잘 표현하는 벡터를 찾는 것 입니다. 그럼 어떻게  찾을 수 있을까요?

이를 수식적으로 한번 풀어보도록 하겠습니다.

d i tilda를 임의의 데이터들, d i bar를 모든 데이터들의 평균 d i를 임의의 data에서 data들의 평균을 뺀 센터링 된 데이터라고 아래와 같이 가정해보도록 합시다.


 $$\tilde{d}_{i}=\begin{bmatrix} x_{i}\\ y_{i}\end{bmatrix}\bar{d}_{i}=\begin{bmatrix} \bar{x}_{i}\\ \bar{x}_{i}\end{bmatrix}d_{i}=\tilde{d}_{i}-\bar{d}_{i}$$


두 번째로는 이 데이터들의 분포을 잘 나타내는 벡터 u를 구하는 것 입니다.

그럼 데이터들의 분포를 잘 나타낸다는 건 어떤 의미를 담고 있는지 생각해 볼 필요가 있습니다.

데이터들의 분포를 잘 나타 낸다는 것은 센터링 된 임의의 데이터인 di를 딱 선정 한 뒤 원점으로부터 해당 데이터와 연결하여 벡터를 구했을 때 벡터 di와의 차이와 벡터 u의 차이가 가장 작은 벡터라는 의미로 해석할 수 있습니다.

그리고 어떤 데이터는 벡터 u와의 차이가 크지만 어떤 데이터는 작을 수 있기 때문에 

우리는 데이터 벡터인 di와 벡터 u 차이를 모두 구해준 뒤 모두 합하였을 때 최소 값이 되는 벡터 u를 찾으면 pca는 끝이라는 겁니다.

그럼 이를 수식으로 풀어보도록 하겠습니다.


$$ min\ d_{i}-{d_{i}}^{T}\cdot\bar{u}\cdot\bar{u}\\ \Rightarrow \frac{1}{N}min\sum_{i}^{N}(d_{i}-{d_{i}}^{T}\cdot\bar{u}\cdot\bar{u})^{T}(d_{i}-{d_{i}}^{T}\cdot\bar{u}\cdot\bar{u}) $$



$$ min\ d_{i}-{d_{i}}^{T}\cdot\bar{u}\cdot\bar{u}\\\Rightarrow \frac{1}{N}min\sum_{i}^{N}(d_{i}-{d_{i}}^{T}\cdot\bar{u}\cdot\bar{u})^{T}(d_{i}-{d_{i}}^{T}\cdot\bar{u}\cdot\bar{u})\\=\frac{1}{N}\sum_{i}^{N}(d_{i}{d_{i}}^{T}-{d_{i}}^{T}\bar{u}\cdot{\bar{u}}^{T}d_{i}-{d_{i}^{T}}({d_{i}^{T}\bar{u}})\bar{u}+{d_{i}^{T}}\bar{u}\bar{u}^{T}({d_{i}^{T}\bar{u}}){\bar{u}})\\=-\frac{1}{N}\sum_{i}^{N}\bar{u}^{T}d_{i}\cdot{d_{i}}^{T}\bar{u}
\\=-\bar{u}^{T}\frac{1}{N}\sum_{N}^{i}(\tilde{d}_{i}-\bar{d}_{i})(\tilde{d}_{i}-\bar{d}_{i})^{T}\bar{u}\\=-\bar {u}^{T}R_{d}\bar{u} $$




$$s.t\ R_{d}=\frac{1}{N}\sum_{N}^{i}(\tilde{d}_{i}-\bar{d}_{i})(\tilde{d}_{i}-\bar{d}_{i})^{T}\bar{u}$$



그리고 위와 같은 수식을 Sample Covariance matrix이며, R_{d} 위와 같이 표현하도록 하겠습니다.

여기서 먼저 Covariance 즉 공분산에 대한 뜻부터 알아보도록 하겠습니다.

공 분산이란 예를 들어 스칼라인 X와 Y 두 확률변수 Radom variable이 있을 때, 이 X와 Y가 어떤 상관 관게가 있는지 살표 보기 위한 분산입니다. 

여기서 Covariance가 0이라면 X와 Y는 서로 상관이 없는 확률 변수라는 의미 입니다.

만약 Covariance가 0 초과인 양수 값이면 X가 커지면 Y도 커지는 성질을 가지고 있으며, 0 미만인 음수 값이면  X가 커질 때 Y는 작아지는 성질을 가지고 있다는 뜻 입니다.

그럼 Covariance matrix는 뭘까요?

우리가 Covariance는 확률 변수 Random variable X Y에 관한 상관 관계를 다루었다면 Covariance matrix는 확률 벡터 즉 Random vector X Y에 관한 상관 관계를 다루는 것 입니다.

우리가 일반적인 vector에서는 각 원소들이 스칼라를 의미하는 것이였다면 Random vector에서는 스칼라 확률 변수라고 생각하면 됩니다.

공분산 행렬은 아래와 같이 생겼습니다.

![Untitled 8](https://github.com/jusunglee-ai/jusunglee-ai.github.io/assets/125032849/e44bbd92-7ab3-4752-804e-eb5ae3ed2911)

자 그럼 우리는 데이터의 분포를 잘 나타내는 벡터 u와 임의의 데이터 벡터 d_{i}와의 차이를 최소화 시켜주는 벡터 u를 찾는게 목적이었고 이를 수식으로 풀었을 때 -uRu가 나왔습니다.

그럼 최대화 시켜주는 값은 무엇일까요? 바로 -를 뺀 uRu가 나오게됩니다. 

그럼 이를 라그랑주 승수법을 이용해서 풀어보도록 하겠습니다.


$$max\ \bar{u}^{T}R_{d}\bar{u}\ (R_{d}=\frac{1}{N}\sum_{i}^{N}\bar{d_{i}}-\bar{d_{i}^{T}})\\L=\bar{u}^{T}R_{d}\bar{u} +\lambda (1-\bar{u}^{T}\bar{u})\\dL_{\bar{u}}= d\bar{u}^{T}R_{d}\bar{u}+\bar{u}^{T}R_{d}d\bar{u}-\lambda d\bar{u}^{T}\bar{u}-\lambda \bar{u}^{T}d\bar{u}\\=2\bar{u}^{T}R_{d}d\bar{u}-2\lambda \bar{u}^{T}d\bar{u}\\=(2\bar{u}^{T}R_{d}-2\lambda \bar{u}^{T})d\bar{u} $$


그리고 아래의 수식은 어떤 의미를 가지냐면 바로 L을 u로 미분한 값이라는 의미를 가지게 됩니다.

그리고 이 값은 0이 되어야 하기 때문에 이 조건을 만족시키는 u 중에서 가장 maximaize하는 u를 선별하여 찾으면 우리는 끝이라는 겁니다.


$$\frac{dL}{d\bar{u}^{T}}=(2\bar{u}^{T}R_{d}-2\lambda \bar{u}^{T})d\bar{u}\\
=[\frac{dL}{du_{1}},\frac{dL}{du_{2}},\frac{dL}{du_{3}}...]=0$$


그럼 한번 찾아 보도록 합시다.


$$(\bar{u}^{T}R_{d})^{T}=(\lambda \bar{u}^{T})^{T}\\\Rightarrow R_{d}\bar{u}=\lambda \bar{u}$$


어 그런데 보면 수식이 많이 익숙하지 않나요? 바로 eigen value와 eigen vector입니다. 그래서 PCA는 eigen value와 eigen vector의 확장 영역인 겁니다.

사실 교수님이 저널 주신게 PCA저널을 주셧는데 이거 하나 보려고 선대 앵간한거 다봤어요…

자 그럼 위 조건을 만족하는 vector u를 찾아보도록 합시다.

vector u는 R_d의 eigen vector이기 때문에 symetric하며 orhthogonal matrix로 decompose가 가능합니다.

그럼 한번 전개해보도록 합시다.


$$\bar{u}^{T}R_{d}\bar{u}=\bar{u}^{T}(\lambda_{1}q_{1}q_{1}^{T}+\lambda_{2}q_{2}q_{2}^{T}+...)\bar{u}$$


위의 전개된 수식에서 vector u는 R_d의 eigen vector이기 때문에 q_1, q_2 등등 중에 하나라는 의미 입니다.
그리고 우리가 수식을 전개할 때 lambda_1과 lambda_2를 크기 순서대로 즉 내림차순으로 전개하였다면 vector u는 q1 q2 등등 중에서 어떤 q일 때 람다 값을 가장 크게 가질까요?

바로 q1이겠죠. 

그럼 우리는 이렇게 해석할 수 있습니다.

우리가 구하고자 하는 것은 u^T R_d u가 최댓값을 가지게 하는 vector u를 구하는 것이기 때문에 R_d의 eigen vector중에서 eigen value값이 가장 큰 eigen vector는 바로 q1이며,  이 q1은 바로 첫 번째 주성분 vector라고 표현할 수 있습니다.

그 다음 2번째 주성분 벡터는 무엇일까요? 바로 q2 입니다.

근데 우리가 R_d는 eigen vector이기 때문에 orthogonal하다고요. 그럼 q1과 q2는 첫 번째, 두 번째 주성분 벡터이며 q1과 q2는 orthogonal하기 때문에 첫 번째 주성분 벡터와 두 번째 주성분 벡터는 수직인 것 입니다.

자 그럼 PCA의 조건 두 가지를 살펴보면서 정리한 뒤 마치도록 하겠습니다.

1.분산이 가장 큰 방향이 첫 번째 주성분 벡터이며, 데이터의 분포를 잘 설명한다.

2.두 번째 주성분 벡터는 서로 직교하며 수직 방향이다.

우리가 임의의 데이터를 잡고 원점으로부터 데이터를 연결하여 임의의 데이터 벡터를 만들고 

이 데이터 벡터가 데이터의 분포를 잘 나타내는 벡터 즉 주성분 벡터랑 비교하였을 때 이 두 벡터간의 차이를 최소화 시켜주는 주성분 벡터를 구하는게 우리의 목적이였죠.

그리고 이를 수식으로 풀었을때 아래의 조건을 만족 하는 vector u와 람다가 바로 solution이였다는 겁니다.

여기서 이 vector u가 두 벡터간의 차이를 최소화 하는 방향이 였다는 것 이였고 이 vector u는 covariance의 가장 큰 eigen value에 해당하는 eigen vecotr였다는 것 입니다.


$$R_{d}\bar{u}=\lambda \bar{u}$$


즉 분산이 가장 큰 방향이 우리가 찾고자하는 주성분 벡터였다는 것 입니다.

그리고 두 번째로 큰 방향의 주성분 벡터를 찾았더니 첫 번째 주성분 벡터랑 직교하여 수직 방향이였다는 것 입니다.

그래서 PCA에서 조건 1번 2번이 생긴거구나 라고 이해하면 됩니다.


$$max\ \bar{u}^{T}R_{d}\bar{u}\ (R_{d}=\frac{1}{N}\sum_{i}^{N}\bar{d_{i}}-\bar{d_{i}^{T}})\\L=\bar{u}^{T}R_{d}\bar{u} +\lambda (1-\bar{u}^{T}\bar{u})\\dL_{\bar{u}}= d\bar{u}^{T}R_{d}\bar{u}+\bar{u}^{T}R_{d}d\bar{u}-\lambda d\bar{u}^{T}\bar{u}-\lambda \bar{u}^{T}d\bar{u}\\=2\bar{u}^{T}R_{d}d\bar{u}-2\lambda \bar{u}^{T}d\bar{u}\\=(2\bar{u}^{T}R_{d}-2\lambda \bar{u}^{T})d\bar{u} $$


